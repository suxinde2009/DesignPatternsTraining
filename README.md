DesignPatterns_iOS
==================

Personal scribble demos while learning design patterns.

------------------

### 设计模式主要分三个类型:创建型、结构型和行为型。
 
#### 创建型 <br/>
##### 一、Singleton，单例模式 <br/>
保证一个类只有一个实例，并提供一个访问它的全局访问点 <br/>

![image1](./Graphs/UML-Singleton.PNG)

##### 二、Abstract Factory，抽象工厂 <br/>
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。<br/>

![image1](./Graphs/UML-AbstractMethod.PNG)

a. 抽象工厂与工厂方法的区别  <br/>

抽象工厂： <br/>
（1）通过对象组合创建抽象产品； <br/>
（2）创建多系列产品； <br/>
（3）必须修改父类的接口才能支持新的产品。 <br/>

工厂方法： <br/>
（1）通过类继承创建产品； <br/>
（2）创建一种产品； <br/>
（3）子类化创建者并重载工厂方法以创建新产品。 <br/>



##### 三、Factory Method，工厂方法  <br/>
定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。<br/>

![image1](./Graphs/UML-FactoryMethod.PNG)

 a. 何时使用 <br/>
（1）编译时无法确定预期要创建的对象的类；<br/>
（2）类想让其子类决定运行时创建什么；<br/>
（3）类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。<br/>
   工厂方法模式让客户程序可以要求由工厂方法创建的对象拥有一组共同的行为。所以往类层次结构中引入新的具体产品并不需要修改客户端代码，因为返回的任何具体对象的接口都跟客户端一直在用的从前的接口相同。<br/>
   工厂设计模式是面向对象软件设计中应用非常普遍的设计模式。工厂方法从代码中消除了对应用程序特有的耦合。代码只需要处理Product抽象接口。所以同一代码得以复用，在应用程序中与用户定义的任何ConcreteProduct类一起工作。<br/>


##### 四、Builder，建造模式 <br/>
将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。<br/>

![image1](./Graphs/UML-Builder.PNG)

##### 五、Prototype，原型模式  <br/>
用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。<br/>

![image1](./Graphs/UML-Prototype.PNG)

 b. 何时是用原型模式 <br/>
（1）需要创建的对象应独立于其类型与创建方式。<br/>
（2）要实例化的类是在运行时决定的。<br/>
（3）不想要与产品层次相对应的工厂层次。<br/>
（4）不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便。<br/>
（5）类不容易创建，比如每个组件可以把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易。<br/>

c. 浅复制与深复制 <br/>
如果对象有个指针型成员变量指向内存中的某个资源，那么如果复制这个对象呢？指针只是存储内存中资源地址的占位符。如果复制操作中，只是将指针复制给新对象（副本），那么底层的资源是架上仍然由两个实例在共享。<br/>
因此只复制了指针而不是实际资源，这成为浅复制。<br/>
深复制是指不仅复制指针值，还复制指针所指向的资源。不只是简单的复制资源指针，还要生成内存中实际资源的真正副本。因此副本对象的指针指向了内存中不同位置的统一资源（内容）的副本。<br/>

d. Cocoa Touch框架中的对象复制<br/>
CocoaTouch框架为NSObject的派生类提供了实现深复制的协议。NSObject的子类需要实现NSCopying协议及其方法--（id）copyWithZone:(NSZone *)zone。NSObject有一个实例方法叫做（id）copy。默认的copy方法调用[selfcopyWithZone:nil]。对于采纳了NSCopying协议的子类，需要实现这个方法，否则将引发异常。IOS中，这个方法保持新的副本对象，然后将其返回。此方法的调用者需要负责释放返回的对象。<br/>

深复制的技巧在于：保证确实复制了内存中的资源，而不只是指指针。


此模式的最低限度是生成对象的真实副本，以用作同一环境下其他相关事物的基础（原型）。

#### 行为型 <br/>
##### 六、Iterator，迭代器模式  <br/>
提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。<br/>
##### 七、Observer，观察者模式  <br/>
定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。<br/>

![image1](./Graphs/UML-Observer.PNG)

##### 八、Template Method，模板方法 <br/>
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。<br/>

![image1](./Graphs/UML-Template.PNG)

a. 何时使用 <br/>
(1) 需要一次性实现算法的不变部分，并将可变的行为留给子类实现 <br/>
(2) 子类的共同行为应该被提取放到公共类中，以避免代码重复。现有代码的差别应该被分离为新的操作。然后用一个调用这些操作的模板方法来代替这些不同的代码。<br/>
(3) 需要控制子类的扩展。可以定义一个在特定点调用的“钩子”(hook)操作的模板方法。子类可以通过钩子操作的实现在这些扩展点扩展功能。<br/>

b. 模板方法调用5种类型的操作 <br/>
(1) 对具体类或者客户端类的具体操作 <br/>
(2) 对抽象类的具体操作 <br/>
(3) 抽象操作 <br/>
(4) 工厂方法 <br/>
(5) 钩子操作 <br/>

##### 九、Command，命令模式  <br/>
将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。<br/>

![image1](./Graphs/UML-Command.PNG)

##### 十、State，状态模式 <br/>
允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。<br/>

![image1](./Graphs/UML-State.PNG)

##### 十一、Strategy，策略模式 <br/>
定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。<br/>

![image1](./Graphs/UML-Strategy.PNG)

##### 十二、Chain of Responsibility，职责链模式 <br/>
使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 <br/>

![image1](./Graphs/UML-ChainOfResponsibility.PNG)

##### 十三、Mediator，中介者模式 <br/>
用一个中介对象封装一些列的对象交互。 <br/>

![image1](./Graphs/UML-Mediator.PNG)

##### 十四、Visitor，访问者模式 <br/>
表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。<br/>

![image1](./Graphs/UML-Visitor.PNG)

##### 十五、Interpreter，解释器模式 <br/>
给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br/>
##### 十六、Memento，备忘录模式 <br/>
在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br/>

![image1](./Graphs/UML-Memento.PNG)

#### 结构型有 <br/>
##### 十七、Composite，组合模式 <br/>
将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。<br/>

![image1](./Graphs/UML-Composite.PNG)

##### 十八、Facade，外观模式 <br/>
为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。<br/>

![image1](./Graphs/UML-Facade.PNG)

##### 十九、Proxy，代理模式 <br/>
为其他对象提供一种代理以控制对这个对象的访问 <br/>

![image1](./Graphs/UML-Proxy.PNG)

##### 二十、Adapter,适配器模式 <br/>
将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。<br/>

![image1](./Graphs/UML-Adapter.PNG)

##### 二十一、Decorator，装饰模式 <br/>
动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。<br/>

![image1](./Graphs/UML-Decorator.PNG)

##### 二十二、Bridge，桥模式 <br/>
将抽象部分与它的实现部分相分离，使他们可以独立的变化。<br/>

![image1](./Graphs/UML-Bridge.PNG)

##### 二十三、Flyweight，享元模式 <br/>
运用共享技术有效的支持大量细粒度的对象。

![image1](./Graphs/UML-Flyweight.PNG)

a. 何时使用 <br/>
（1）应用程序使用很多对象；<br/>
（2）在内存中保存对象会影响内存性能；<br/>
（3）对象的多数特有状态（外在状态）可以放到外部而轻量化；<br/>
（4）移除了外在状态后，可以用较少的共享对象替代原来的那组对象；<br/>
（5）应用程序不依赖于对象标示，因为共享对象不能提供唯一的标示。




<br/>  除了以上23个模式之外，根据《java与模式》中的分类，还有4种模式，DefaultAdapter 缺省适配器模式，SimpleFactory 简单工厂模式，Multiton 多例模式, Immutable 不变模式。
